---


---

<h1 id="c-10.11.2018">C++ 10.11.2018</h1>
<p><em>Обзорная экскурсия по потокам</em></p>
<p>Самые низкоуровневые (но самые ходовые?) примитивы с прошлой лекции</p>
<ul>
<li>mutex (dead lock? - 1 поток ждет другого, а другой ждет первого)<br>
<a href="https://ru.cppreference.com/w/cpp/thread/mutex">https://ru.cppreference.com/w/cpp/thread/mutex</a></li>
<li>conditional_variable<br>
<a href="https://ru.cppreference.com/w/cpp/thread/condition_variable">https://ru.cppreference.com/w/cpp/thread/condition_variable</a></li>
<li>atomic<br>
<a href="https://ru.cppreference.com/w/cpp/atomic/atomic">https://ru.cppreference.com/w/cpp/atomic/atomic</a></li>
</ul>
<p>В <strong>c++11</strong> добавлены новые классы<br>
Эти примитивы не очень часто применяются<br>
<strong>примитив_1</strong></p>
<ul>
<li>хотим дождаться какого-то результата<br>
promise (чуваку который считает) + future (чуваку который хочет получить, он будет делать get)<br>
promise:<br>
set_value<br>
set_exception</li>
</ul>
<p><strong>примитив_2</strong></p>
<ul>
<li>
<p>packaged_task<br>
<a href="https://ru.cppreference.com/w/cpp/thread/packaged_task">https://ru.cppreference.com/w/cpp/thread/packaged_task</a><br>
реализует интерфейс</p>
<p>T f() promise<br>
void ()</p>
</li>
</ul>
<p><strong>вариант_3</strong></p>
<ul>
<li>
<p>std::async()<br>
как мы разрешаем ему считать (в отдельном потоке/ лениво - досчитать, когда будет get())<br>
<a href="https://ru.cppreference.com/w/cpp/thread/async">https://ru.cppreference.com/w/cpp/thread/async</a></p>
<p>T f() -&gt; future<br>
future для одного пользователя (мувается), есть shared_future(?), но он работает по-другому.</p>
</li>
</ul>
<p><strong>thread_pool</strong> //нет отдельного класса в стд</p>
<ul>
<li>Есть ли способы убить поток? (допустим мы закрываем окно). В винде 1 и тот плохой (не вызываются деструкторы, mutex не отпускается, например если в момент прерывания был вызов malloc --&gt; может произойти, что угодно, особенно учитывая то, что компилятор может переставить порядок операций, нельзя гарантировать, что прерывание потока ничего не сломает). Мб такой способ был бы применим, если функция не работает с памятью.<br>
Правильный способ - сообщить потоку, чтобы он вышел сам. (Будет ли работать вызов exception внутри потока? Структуры данных становятся некорректными. реально это не работает). Тред можно прерывать только в определнных местах, где он может раскрутиться (точки канцеляции).</li>
</ul>
<p>Зачем нужно иметь все это в библиотеке? У нас есть места, где мы ждем, а нас попросили заканселиться. Есть пользователь сам написал механизм - пользователь будет продолжать ждать (нужен mutex log?).<br>
В стандартную библотеку не взяли: condition, mutex сделаны в зависимости от компиляторов /glibc условно работает. Ее достаточно сложно поддержать (нижелижащие библиотеки не всегда поддерживают), это замедляет примитивы.<br>
Такого рода механизмы пишут снаружи --&gt; праблемы канцелиться</p>
<p><strong>thread local storage</strong></p>
<ul>
<li>Своя локальная переменная для треда<br>
<a href="https://stackoverflow.com/questions/11983875/what-does-the-thread-local-mean-in-c11">https://stackoverflow.com/questions/11983875/what-does-the-thread-local-mean-in-c11</a><br>
Работая с общими данными - всегда будем замедляться --&gt; можно сделать несколько копий этих данных (если мы только читаем файл, то это конечно не проблема). Так кстати работают аллокаторы памяти. Имеет те же минусы, что и глобальные переменные - на практике применяются не очень часто (в нужные моменты нужно записать/прочесть)<br>
Еще есть варианты хранить предка (но бегать наверх это o(h) дерева), можно протаскивать переменные через кучу функций (в каждой функции отдельный дополнительный аргумент).</li>
</ul>
<p>STM</p>
<ul>
<li>Хотим чтобы кусок кода исполнился неделимо (atomic) либо видим результит, либо не видим вообще.</li>
</ul>
<p>HTM (hardware transactional memory)<br>
<a href="https://en.cppreference.com/w/cpp/language/transactional_memory">https://en.cppreference.com/w/cpp/language/transactional_memory</a></p>
<ul>
<li>то же самое (хочу получить блок atomic) с поддержкой железа для транзакций. У процессора есть кэш L1, когда транзакцию закончили - инвалидировали/очистили данный.</li>
</ul>
<hr>
<p><strong>reduce</strong>, MapReduce<br>
<a href="https://en.cppreference.com/w/cpp/algorithm/reduce">https://en.cppreference.com/w/cpp/algorithm/reduce</a><br>
a*(b<em>c) = (a</em>b)*c</p>
<p>Не любая задача допускает распараллеливание<br>
Хочу разбить на токены<br>
int a = 1;<br>
int = keyword; 1 = numeral…<br>
Один с начала - другой с конца парсит, что если комментарий до конца файла? Некоторые задачи не имеет смысла параллелить или нет ожидаемого ускорения:</p>
<ul>
<li>Дефрагментация жесткого диска, к примеру, не параллелится (только замедлится), диск однопооточный и медленный - все потоки будут просто ждать, когда он запишет порцию данных. Так что имеет смысл оставлять только один поток. Выигрыша не получается, если упираться в какой-то ресурс.</li>
<li>Пропускная способность оперативной памяти тоже общий ресурс. Причина по которой memcpy вряд ли ускорится от распараллеливания (на десктопе).</li>
<li>Кэши процессора</li>
<li>Hyper-threading</li>
</ul>
<p>Эффекты:</p>
<ul>
<li>turbo boost</li>
<li>sharing<br>
N ++n; (std::atomic) --&gt; n = 320млн</li>
</ul>


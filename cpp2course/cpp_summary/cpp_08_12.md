---


---

<h1 id="section">08.12.2018</h1>
<h2 id="хранение-на-диске">хранение на диске</h2>
<p>foo/<br>
- bar<br>
- baz<br>
- qux<br>
На самом деле хранилось не в directory, а в inode <a href="https://ru.bmstu.wiki/Inode_(%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BD%D1%8B%D0%B9_%D0%94%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80)">https://ru.bmstu.wiki/Inode_(Индексный_Дескриптор)</a><br>
=&gt;можно двумя элементами каталога сослаться на элемент в ноде (hard link)<br>
Бывают symlinks - вместо файла лежит путь к файлу (они могут ссылаться друг на друга (рекурсивно) поэтому глубина симлинка ограничена, при открытии файла есть специальный бит “я знаю, что это симлинк”<br>
Не все файловые системы хранит такие inode (<a href="https://ru.wikipedia.org/wiki/FAT">https://ru.wikipedia.org/wiki/FAT</a>)<br>
Другие примеры: <a href="https://en.wikipedia.org/wiki/XFS">https://en.wikipedia.org/wiki/XFS</a> (работать с файлами большого объема)</p>
<ul>
<li>открытый файл ссылается на inode (все другие такие же файлы будут видеть эти изменения), что будет если открыть файл, а потом его удалить? - ничего не будет, в одном месте удалится, в другом останется висеть (пока открыт и ссылка не потеряна можно обращаться). Раньше добавить обратно его было нельзя (сейчас появились api для этого) =&gt; временные данные можно хранить в inode.</li>
</ul>
<p><code>if (exists(filename)) {}</code><br>
плохо, тк как операция не атомарная, не дает никакой полезной информации<br>
=&gt; нужно просто открыть файл`</p>
<p>Некоторые операции хочется точно делать атомарно, например перетереть файл -&gt; rename/move поверх существующих, то есть можно создать новый файл на том же разделе, потом свапнуть на место старого - нет необходимости создавать ноды в воздухе.</p>
<hr>
<p>во что раскрывается</p>
<pre><code>for (int a : v) {}
</code></pre>
<p>ведь v.begin(), v.end() нет у массивов, а хочется чтобы работало со всем -&gt; сделать внешнюю перегруженную функцию<br>
Пример: есть vector.swap, но есть и оболочка std::swap<br>
=&gt; добавляется namespace std для такого цикла</p>
<p><strong>2 расширение</strong>.</p>
<pre><code>typename
std::vector&lt;T&gt;::const_iterator
f(std::vector&lt;int&gt; const&amp;);

void g(std::vector&lt;int&gt;&amp; v) {
    v.erase(f(v), v.end());
}
</code></pre>
<p>Применяем к erase разные типы (мб в 11 плюсах и будет работать, но вот например</p>
<pre><code>std::find(f(v), v.end());
</code></pre>
<p>точно работать не будет<br>
Можно прикастить, но это надо много писать, проще использовать v.cend(); =&gt; но забыли сделать cbegin(), cend() в namespace std;</p>
<p>При написании лямбд либо по значению захват, либо по ссылке</p>
<pre><code>int a = 5;
[a]{...}
[&amp;a]{...}
</code></pre>
<p>Но для лямбд не было мува. Позже в c++14 добавили и инициализацию</p>
<pre><code>[a = std::move(a)]{}
</code></pre>
<p>Нужно что бы засунуть некопируемый объект (unique_ptr) или строчку, которая уже не нужна</p>
<p>Этой языковой фичи все еще нет:</p>
<pre><code>std::vector&lt;int&gt; a = {b, c, d};
</code></pre>
<p>Внутри std::initializer&lt;'int&gt;<br>
int const* begin();<br>
int const* end();</p>
<pre><code>std::vector&lt;string&gt; a = {"foo", "bar", std::move(s)};
</code></pre>
<p>s все равно скопируется дважды, тк еще копируется внутрь массива initializer листа</p>
<hr>
<p><strong>Вопрос про треды</strong><br>
как создается тред</p>
<pre><code>import libstdc++
std::thread
//В этой реализации
    _M_start_thread
    //все еще libstdc++
//Функция внутри себя вызывает
		__gthread_create
		//а это уже glibc
в glibc это не что иное, как обертка над
__gthrw_pthread_create - это weak alias
...
системный вызов clone - это был уровень glibc
</code></pre>
<p>Как работает clone - уйти в ядро через syscall, но это не единственный способ, исторически int0x80<br>
Бывают системные вызовы, которые не обязаны уходить в ядро (например, поддержка текущего времени)</p>
<hr>
<p>Как работает динамически загружаемая библиотека<br>
1 .o .o .o .o<br>
2 a.out (сборка при помощи ld)<br>
3. /a.out<br>
a - exe, исполняемый файл, но ведь кроме объектных есть еще сошки (.so) - <em>shared object</em><br>
Проблема 1: чтение глобальной переменной</p>
<pre><code>mov rax, [var] -- 0x2345678
//какое число написать вместо var
</code></pre>
<p>.so не может всегда загружаться по одному адресу<br>
to [-------------][jmp here][][][][--------------]<br>
from [][0x1234][][][][][][]<br>
Куда этот адрес добавится? Можно всегда в определенное место в памяти, но .so не может всегда загружаться по одному адресу – <strong>грустный смайл</strong><br>
Можно в теории в новое адресное пространство, но это новая программа. Как в то же адресное пространство<br>
Будем передавать еще переменную, куда он загрузился - зарезервируем регистр под эти цели (куда части нашей программы загружены в памяти)<br>
У такого подхода есть минус, допустим вызываем f - должны мы этот регистр перетереть или нет?<br>
<strong>Еще способы</strong> relocations table “где адреса нужно обновить” (ставим куда-нибудь, по пути от нужного места перезаписываем все ссылки, мапя их в таблице)<br>
с dll существует base address (предпочтительный адрес)<br>
можно также пробежаться и сделать  loc += x - base_address, чтобы найти адрес (так сделано в винде)</p>
<pre><code>foo:
...
    jmp foo
</code></pre>
<p>jmp прыгает по относительному адресу (хранится не только число) -&gt; для call &amp; jmp этих проблем нет, проблемы только со взятием адреса итд --&gt; одно из решений: все считать по относительному адресу<br>
Код, который всегда ссылается по относительным адресам - PIC (position independent code) для x64, для x32 такое тоже есть, но это неэффективно</p>

